import json
import os
import sys
from modules.cve_lookup import query_nvd_api, query_circl_api

def resource_path(relative_path):
    """
    Get absolute path to resource, works for dev and for PyInstaller.
    """
    try:
        base_path = sys._MEIPASS
    except Exception:
        base_path = os.path.abspath(".")
    return os.path.join(base_path, relative_path)

VULN_DB_PATH = resource_path(os.path.join("data", "vuln_db.json"))

def load_vuln_db():
    """
    Load the static vulnerability database from a JSON file.
    Raises RuntimeError on failure.
    """
    try:
        with open(VULN_DB_PATH, "r", encoding="utf-8") as f:
            return json.load(f)
    except Exception as e:
        raise RuntimeError(f"Failed to load vulnerability DB: {e}")

def lookup_cves(keyword):
    try:
        return query_nvd_api(keyword)
    except Exception:
        try:
            return query_circl_api(keyword)
        except Exception:
            return []

def detect_vulnerabilities(banner_list, vuln_db):
    report_lines = []
    vuln_found = False
    remediation_items = set()

    for port, banner in banner_list:
        banner_normalized = banner.strip()
        report_lines.append(f"\n🔍 Port {port} Banner: {banner_normalized}")
        matched_static = False

        for vuln_string, details in vuln_db.items():
            if vuln_string.lower() in banner_normalized.lower():
                matched_static = True
                vuln_found = True
                report_lines.append(
                    f"⚠️ Static DB Match:\n"
                    f"   → CVE    : {details.get('cve', 'N/A')}\n"
                    f"   → Advice : {details.get('advice', 'N/A')}"
                )
                remediation_items.add(details.get("advice", "Apply vendor security updates."))

        if not matched_static:
            report_lines.append("✅ No static DB vulnerabilities found.")

        keyword = banner_normalized.split()[0] if banner_normalized else ""
        live_results = lookup_cves(keyword)

        if isinstance(live_results, list) and live_results:
            first_id = live_results[0].get("id", "") if isinstance(live_results[0], dict) else ""
            if first_id not in ["Skipped", "Error", ""]:
                vuln_found = True
                for cve in live_results:
                    cve_id = cve.get("id", "N/A")
                    cvss = cve.get("cvss", "N/A")
                    summary = cve.get("summary", "No summary available.")
                    report_lines.append(
                        f"🛡️ Live CVE: {cve_id}  CVSS: {cvss}\n"
                        f"   → {summary}"
                    )
                remediation_items.add("Review and patch CVEs listed above according to severity.")
            else:
                report_lines.append("🔎 No live CVE entries found.")
        else:
            report_lines.append("🔎 No live CVE entries found.")

    details = "\n".join(report_lines).strip()

    if vuln_found:
        return {
            "score": 1.0,
            "status": "Fail",
            "details": details,
            "remediation": (
                "🔧 Remediation:\n" +
                "\n".join(f"- {item}" for item in remediation_items)
            )
        }
    else:
        return {
            "score": 5.0,
            "status": "Pass",
            "details": details,
            "remediation": "✅ No vulnerabilities detected. No remediation needed."
        }

def run_audit(ip=None, banners=None, is_private=None, open_ports=None, shared_data=None):
    if not banners:
        return {
            "score": 0.0,
            "status": "Error",
            "details": "❌ No banner list provided for vulnerability scanner.",
            "remediation": "📥 Pass `banners` to `run_audit()`."
        }

    try:
        vuln_db = load_vuln_db()
    except Exception as e:
        return {
            "score": 0.0,
            "status": "Fail",
            "details": f"❌ Failed to load vulnerability DB: {e}",
            "remediation": "📁 Ensure `data/vuln_db.json` exists and is valid JSON."
        }

    return detect_vulnerabilities(banners, vuln_db)

if __name__ == "__main__":
    test_banners = [
        (80, "nginx/1.18.0"),
        (22, "OpenSSH_7.6p1 Ubuntu-4ubuntu0.3"),
    ]
    result = run_audit(banners=test_banners)
    print(f"Score: {result['score']}\nStatus: {result['status']}")
    print(f"Details:\n{result['details']}")
    print(f"Remediation:\n{result['remediation']}")
